- Source Tree:
	- Tải 'sourcetree' để quản lý source code từ git:
		https://www.sourcetreeapp.com/
		
		- Ctrl+O để mở thư mục 'F:\MERN\project'
			> Vì folder dự án gắn với git sẵn rồi nên chỉ mở folder dự án là sourcetree sẽ tự nhận
		
		- 
			các byuowcs cậu vừa làm là:
			1- commit code > để nó tạo sẵn 1 gói hàng đợi chuẩn bị push lên
			2- pull code > lấy hết code mới nhất từ trên git về máy mình
			3- push code > nếu 1 và 2 không xảy ra lỗi conflict thì push code OK, nghĩa là 1 & 2 hoà quyện code với nhau


*******************************************************

- 	chỉ mục một hành động thực hiện
>>> lệnh 
> 	ghi chú
'' 	liên kết url hoặc folder path
**************************************

- Tạo project đảy lên git
	- Tạo thư mục dự án 'F:\MERN\project'
	- Gõ cmd lên thư mục mở comman line
		>>> git init
			> để cấu hình thư mục \project thành git repo
			> chạy xong lệnh thưc mục .get được tạo
			
		>>> git remote add origin https://github.com/mistertino/mern.git
			> gắn thư mục /project trên pc tới git đã tạo 'https://github.com/mistertino/mern.git'
			
	- Tạo file và folder commit thử lên git
		- Tạo các folder, file:
			\project\css
			\project\js
			\project\index.html		
			
		>>> git add .
			> để add những gì sẽ đưa lên git
			
		>>> git status
			> để xem git add ở bước trên đã xếp những thứ cần đẩy lên git đúng chưa	
			
		>>> git commit -m "commit html css js"
			> tạo một hành động gói hết các thứ bước trên lại để chuẩn bị push lên git
			
		>>> git branch -M main
			> chỉ định một một nhánh (một nơi) chưa cột sẽ commit lên
			
		>>> git push -u origin main
			> đẩy tất cả code lên github
			
		- Kiểm tra code đã lên git chưa?
			> truy cập Code tab trong git để xem 'https://github.com/mistertino/mern'
			
- Pull code tử git có sẵn repo về máy
	- Tạo thư mục chứa code từ git repo về '\nha cau tai'
	>>> git init
		> để cấu hình thư mục \project thành git repo
		> chạy xong lệnh thưc mục .get được tạo
			
	>>> git remote add origin https://github.com/mistertino/mern.git
		> gắn git repo vào thư mục vừa tạo 'https://github.com/mistertino/mern.git'
			
	>>> git branch -M main
		> chỉ định một một nhánh (một nơi) chưa cột sẽ commit lên
		
	>>> git pull origin main
		> Kéo hết code từ nhánh main trên git repo về thư mục
		

- HTTP protocol
	- Đọc thêm tại: 'https://vi.wikipedia.org/wiki/Hypertext_Transfer_Protocol'
- SSR & CSR
	-SSR: Server Side Rendering
		> Giao diện trả về từ sever
	-CSR: Client Side Rendering
		> Giao diện từ client
- Install ExpressJS
	- Tạo packet nodejs
		- Mở Terminal trong VSCode
		>>> npm init 
			> khởi tạo package
			
		- Enter để bỏ qua name, version, description, entry point(file chạy ứng dụng), test command -- <có thể nhập để đổi tên>
		>>> git repository: https://github.com/mistertino/mern
			> khai báo git
			
		- Đặt keyword cho packet và Author 
		
		>>> Enter 
			> để chấp nhận license
			
		>>> Enter 
			> để confirm -> tạo ra file package.json
		
		- Tạo file index.js (cùng tên với tên trong file package.json: "main": "index.js") cùng thư mục chứa file package.json
		
	- Install ExpressJS
		- Mở Terminal trong VSCode
		
		>>> npm install express
		
		- Paste đoạn code tại: 'https://expressjs.com/en/starter/hello-world.html'
				const express = require('express')
				const app = express()
				const port = 3000

				app.get('/', (req, res) => {
					res.send('Hello World!')
				})

				app.listen(port, () => {
				console.log(`Example app listening on port ${port}`)
				})
		
		>>> node index.js
			> Nhập lệnh tại terminal để chạy localhost
			
		- Truy cập địa chỉ 'http://localhost:3000' trên trình duyệt
- Install Nodemon & inspector
	- Install Nodemon
		>>> npm install --save-dev
	
		- Vào file package.json thêm: "start": "nodemon index.js", vào phần: "Scrips"
		
		>>> npm start
			> để chạy localhost (live sever)
			
		- Truy cập địa chỉ 'http://localhost:3000' trên trình duyệt	
		
	- Inspector	
		- Thêm '--inspect' vào phần "start" vừa tạo trên thành  "start": "nodemon --inspect index.js",
			> để debug app
			
		>>> npm start
			> để chạy localhost (live sever)
			
		- Truy cập địa chỉ 'http://localhost:3000' trên trình duyệt	
		
		- Chuột phải Inspect trên trình duyệt -> Có phần debug của NodeJs tại Devtools 
		
		- Chọn tab Sources mở rộng đến file index.js
			> để debug code

- Install Morgan
	>>> npm install morgan --save-dev
	
	- Khai báo const  morgan = require('morgan') vào index.js
			
	- app.use(morgan('combined')) tại index.js
		> để log ra các request
			
- 10. Template engine (handlebars)
	>>> npm install express-handlebars
	
	- Tạo thư mục src rồi move file index.js vào -> src/index.js
	
	- Tại file package.json sửa lại đường dẫn tại 'main' và 'start' (index.js thành src/index.js)
	
	- Trong thư mục src tạo các file,folder như sau:
		\src\resources\scss
		\src\resources\views\home.handlebars
			> để tạo cấu trức file, folder của template
	
	- Tại thư mục views tạo folder và file:
		\views\layouts\main.handlebars
			
	- Require Handlebars
		- Tại file index.js khai báo:
			const { engine } = require("express-handlebars"); (mỗi ver handlebars require khác nhau)
		
		- Require Path
			const path = require("path");
		
		- 	app.engine("handlebars", engine());
			app.set("view engine", "handlebars");
			app.set("views", path.join(__dirname, "resources/views"));

			app.get("/", (req, res) => {

			res.render("home");

			});
				> để chạy file home
		
		- Tại file main.handlebars:
			- Tạo cấu trức file html
				- Trong thẻ <body> thêm: '{{{body}}}'
					> để lấy content của file home apend vào layout là file main
		
	- Config Handlebars
		- Config cho file handlebars	
			- Tại file index.js cấu hình như sau:
				app.engine(".hbs", engine({extname : '.hbs'}));
				app.set("view engine", ".hbs");
					> để cấu hình định dạng file .handlebars thành .hbs (có thể cấu hình định dạng tuỳ ý) 
			- Sửa định dạng .hbs cho các file .handlebars vừa tạo
		
	- Tại thư mục views tạo folder, file như sau:
		\views\partials\header.hbs
		\views\partials\footer.hbs
		
	- Để nạp 2 file vừa tạo ở trên vào main.hbs dùng nhưu sau:
		{{> header}}
		{{> footer}}
			> Viết vào phần body (cấu trúc nạp: {{> tên file}} )

- 11. Static file & SCSS
	- Tạo folder, file như sau:
		\src\public\img
		
	- Cấu hình static file
		- Tại file index.js: app.use(express.static(path.join(__dirname, "public")))
			> để trình duyệt gặp path trên url sẽ kiếm tra thư mực public
				> VD: url = http://localhost:3000/img/logo.png 
	
	- SCSS
		>>> npm install node-sass --save-dev
		
		- Tại thư mục scss tạo file app.scss
		
		- Tại thư mục public tạo folder: \public\css
		
		- Cấu hình compile từ file .scss sang folder css
			- Tại file package.json thêm một scripts:
				"watch": "node-sass --watch src/resources/scss/ --output src/public/css/"
			
			- Tại Terminal:
				>>> npm run watch
					> để compile file app.scss sang app.css (Luôn viết css vào app.scss)
			
		- Link CSS
			- Tại file main.hbs: <link rel="stylesheet" href="/css/app.css">
			
- 12. Use Bootstrap
	- Link Bootstrap:
		- tại file views\layout\main.hbs link bootstrap:
			>>> <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
			>>> <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
				<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js" integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p" crossorigin="anonymous"></script>
				<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js" integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF" crossorigin="anonymous"></script>
				
- 13. Basic routing
	- app.get("/", (req, res) => {
		res.render("home");
	});
		> để sử dụng phương thức get với path (đường dẫn) là "/" và funtion req(request) , res(response)

- 15. Query parameters
	- Tạo 1 file search.hbs
		- views\search.hbs
	
	- Tại index.js thêm:
		app.get("/search", (req, res) => {
			res.render("search");
		});
			> để rout tới search

- 16. Form default behavior
	- Sử dụng bootstrap để tạo form search
	
	- thêm method = "GET" tại thẻ <form>
	
	- thêm name = "q" tại thẻ <input>
		> khi submit nội dung của input được đưa vào query string parameters và  mặc định url được thêm query parameters là /search?q="nội dung input"
	
	- Lấy value của input tại sever:
		- Tại file index.js thêm:
			console.log(req.query) vào funtion (req, res)
				> app.get("/search", (req, res) => {
					console.log(req.query)
					res.render("search");
				});

- 17. POST method
	- Tại thẻ <form> vừa tạo trên sửa method="POST"
		> để phương thức submit của form là post
	
	- tại file index.js thêm:
		app.post("/search", (req, res) => {
			res.send("");
		});
			> để nhận đc request với phương thức POST
	
	- Nhập value vào input rồi submit (VD: Tâm)
	
	- Inspect trên trình duyệt rồi chọn tab Network -> chọn thẻ search -> chọn tab Payload
		> Sẽ thấy được value đã nhập ở input tại Form Data (q: Tâm)
			> Mục đích sử dụng POST để value ko còn ở dạng query parameters (hiển thị trên url) mà được ẩn và đính ở Form Data (dùng cho value nhạy cảm như mật khẩu.....)
		
	- Lấy value của input tại sever:
		-	Tại file index.js:
		app.use(express.urlencoded({
			extended: true
		}));
		app.use(express.json());
			> apply middleware
	
		- Tại file index.js thêm:
			console.log(req.body) vào funtion (req, res) của phương thức post (app.post)
				> app.post("/search", (req, res) => {
					console.log(req.body)
					res.render("search");
				});
					> value của Form Data sẽ đc gắn vào biến body và trả về console.log
					
- 20. [MVC] Routes & Controllers
	- Tại folder views tạo file news.hbs
	
	- Tại folder src tạo file, folder:
		src\routes\news.js
		src\app\controllers\NewsController.js
			> để tách route tại file src/index.js  thành 2 phần route và controller theo MVC 
	
	- Tại file app\controllers\NewsController.js 
		- Tạo 1 class:
			class NewsController {
				index(req, res){
					res.render('news');
				}
			}
				> để tách phần funtion từ file src\index.js qua controller
		- Xuất controller ra
			module.exports = new NewsController;
				> để có thể require NewsController bên ngoài file
	
	
	- Tại folder routes tạo file index.js (.\routes\index.js)
	
	- Tại file routes\index.js tạo 1 funtion route(app) và export nó
		function route(app){

		}

		module.exports = route;
	
	- Tại file index.js ban đầu (\blog\index.js) require  file index.js trong folder routes vừa tạo
		const route = require('./routes/index')
	
		- Truyền biến app từ file routes\index.js vào file \blog\index.js
				route(app); 
				> Sau đó có thể bỏ các route (app.get, app.post,....) đã tạo vào bắt đầu cấu hính route cho từng cái
		
	- Cấu hình router cho file routes\news.js
		- Tại file routes\news.js Require express, use Router và export
			const express = require('express');
			const router = express.Router();

			module.exports = router;	
		
		- Require Controllers (NewsController) được export từ NewsController.js
			const newsController = require('../app/controllers/NewsController');
				> để lấy đc funtion từ NewsController (index(req,res))
		
		- router.use('/', newsController.index);
			> để trỏ router tới path (path tới news) với funtion index được gọi từ NewsController.js

		- Tại file routes\index.js require file news.js đã được export
			const newsRouter = require('./news');
			
			- Tại funtion route(app) :
				app.use('/news', newsRouter);
					> để trỏ route tới newsRouter (news.js) rồi newsRouter trỏ đến và sử dụng function tại NewsController
		
		- Cấu hình nhánh con của route news:
			- Tại file NewsController.js thêm 1 phương thức (VD: show Detail):
				show(req, res) {
					res.send('News Detail');
				}
			
			- Tại file news.js thêm router
				router.use('/:slug', newsController.show);
					> để trỏ router sau news/.. với phương thức show ( router nhánh sau luôn phải nằm trên router nhánh trước)
						> để chạy truy cập address trên trình duyệt : http://localhost:3000/news/hoc-node (sau news/ điền bất kỳ)
							> Áp dụng để tạo nhiều nhánh ( mỗi nhánh có router và controller)
	
	- Cấu hính những file ko nằm trong tài nguyên cụ thể (VD: Home, Search có thể đưa vào chung 1 controller)
		- Tạo các file sau:
			src\routes\site.js
			src\app\controllers\SiteController.js
			
		- Tại SiteController.js làm tương tự như NewsController.js với 2 phương thức của home và search 
			class SiteController {
				home(req, res){
					res.render('home');
				}
				search(req, res){
					res.render('search');
				}
			}
			module.exports = new SiteController;
				> để export ra 2 phương thức home và search
		
		- Tại site.js làm tương tự như news.js require SiteController mới export và sử dụng 2 router cho home và search:
			const express = require('express');
			const router = express.Router();
			const siteController = require('../app/controllers/SiteController');

			router.use('/search', siteController.search);
			router.use('/', siteController.home);

			module.exports = router;
				> để export ra 2 router
				> Lưu ý: router nào nhánh sau thỳ ở trên nhánh trước ở dưới ('/' rồi mới đến '/search')
		
		- Tại file routes\index.js require file site.js rồi trỏ tới siteRouter
			const siteRouter = require('./site');
			app.use('/', siteRouter);
			
		-> Tạo router: Tạo Controller với phương thức rồi export -> Tạo router rồi require Controller rồi export -> Require Router rồi trỏ index tới router
		
- 21. [Windows] Install MongoDB
	- URL: mongodb://localhost:27017
		> để connect tới database
		
- 24. Prettier - Code formatter		
	>>> npm instal prettier lint-staged husky --svae-dev
		> Cài 3 thư viện prettier, lint-staged, husky
	
	- Tại file package.json thêm 1 script:
		    "beautiful": "prettier --single-quote --trailing-comma all --tab-width 4 --write \"src/**/*.{js,json,scss}\"",
			- để thực thi script beautiful : 
				>>> npm run beautiful
					> --single-quote: đổi nháy " thành '
					--trailing-comma all: thêm , cuối mỗi array hoặc object 
	
	- Format code khi commit:
		>>> npm i husky@4.2.5 --save-dev
		
		- Tại file package.json thêm:
			- "lint-staged": {
				"src/**/*.{js,json,scss}": "prettier --single-quote --trailing-comma all --tab-width 4 --write"
			},
			"husky": {
				"hooks": {
				"pre-commit": "lint-staged"
				}
			},
				> Sử dụng 2 thư viện lint-staged và husky để format code khi commit
				
- 25. [MVC] Model
	- Tại MongoDB Compass 
		- Connect và Create DataBase
			- Đặt tên DataBase và Collection Name (blog_education_dev , courses)
				- Truy cập Database vừa tạo (blog_education_dev)
					- Truy cập vào collection (courses)
						- Chọn Add Data -> Insert Doccument -> Chọn view style line
							- Tạo data rồi insert: 	
								name "Xây dựng web với nodeJS & ẼpressJS"
								description "Đây là phần mô tả cho khoá học NodeJS & Express JS"
								image "https://upload.wikimedia.org/wikipedia/vi/a/a7/Nodejs_logo_light.png"
	
	- Install Mongoose
		>>> npm install mongoose
		
	- Kết nối MongoDB
		- Tạo một database trên MongoDB Compass:
			- tên database: blod_education_dev , collection: courses
			
		- Tại folder src tại folder và file sau:
			src\config\db\index.js
			
		- Tại file src\config\db\index.js require mongoose tạo 1 funtion để connect rồi export
			const mongoose = require('mongoose');
			async function connect(){
				try{
					await mongoose.connect('mongodb://localhost:27017/blog_education_dev');
					console.log('Connected to MongoDB');
				}
			catch(e){
				console.log('Connect failed');
				}
			}
			module.exports = {connect}
			
		- Tại file src/index.js require file db\index.js vừa export
			const db = require('./config/db/index');
			
			- db.connect();
				> để connect tới Database
					> Nếu connect failed có thế sửa localhost tại file db\index.js thành 127.0.0.1
					
	- Create Model
		- Tạo file, folder sau:
			src\app\models\Coures.js
		
		- Tại file src\app\models\Coures.js :
			const mongoose = require('mongoose');
			const Schema = mongoose.Schema;
			
			const Course = new Schema({
				name: {type: String, maxLength: 255},
				description: {type: String, maxLength: 600},
				image: {type: String, maxLength: 255 },
				createAt: {type: Date, default: Date.now},
				updateAt: {type: Date, default: Date.now},
			});
				> để khai báo Schema tương ứng với document tại collection của database blod_education_dev
		
			module.exports = mongoose.model('courses', Course);
				> để export ra model chứa collection: 'courses', và Schema: Coures
					> tên collection phải giống với collection tại database
		
		- Để trả data từ database cho client:
			- Tại file src/app/controllers/SiteController.js:
				- Trong hàm home(req,res)
					thay thế render bằng :
						Course.find({}, function (err, courses) {
							if (!err) {
								res.json(courses);
							} else {
								res.status(400).json({ err: 'ERROR!' });
							}
						});
							> để trả về document của collection 'courses' dưới dạng json
	
- 26 Install JSON viewer extension
	- Install JSON viewer extension trên trình duyệt
		> để xem file json dễ hơn

- 27. [CRUD] Read from DB
	- Thêm 2 bản ghi tương tự bản ghi đầu tại collection courses
		- html, JS
		
	- Xử lý data từ database (map data sang dạng Object bình thường)
		- Tạo file, folder:
			src\util\mongoose.js
		
		- Tại src\util\mongoose.js
			module.exports = {
				multipleMongooseToObject: function (mongoose) {
					return mongoose.map((mongoose) => mongoose.toObject());
				},
				// Để sử dụng cho array document
			mongooseToObject: function (mongoose) {
					return mongoose ? mongoose.toObject() : mongoose;
				},
				// để sử dụng cho 1 document
			};
				> để export ra hàm xử lý document cho mongoose
			
	- Tại file src\app\controllers\SiteController.js:
		- Require funtion multipleMongooseToObject từ file src\util\mongoose.js vừa tạo
			const { multipleMongooseToObject } = require('../../util/mongoose');
		
		- sửa phương thức home như sau:
			home(req, res, next) {
				Course.find({})
				.then((courses) => {
					res.render('home', {
						courses: multipleMongooseToObject(courses), // để render ra trang home và mang kèm theo data courses được xử lý bởi hàm multipleMongooseToObject
					});
				})
				.catch(next);
			}
				> để render ra trang home và mang kèm theo data courses được xử lý bởi hàm multipleMongooseToObject
	
	- Truyền data vào views (file.hbs - handlebars)
		- Tại file views\home.hbs sử dụng Component/Card của bootstrap để tạo giao diện với 1 card chứa (image, name, description)
		
		- Để truyền data vào home.hbs (tạm gọi là giao diện home) sử dụng cấu trúc: (đọc thêm tại: https://handlebarsjs.com/guide/#evaluation-context)
			{{#each 'courses'}}
				{{this}}
			{{/each}}
				> courses: biến chứa data được truyền vào từ SiteController
				> dùng each để lặp các document có trong collection (các bản ghi có trong bảng) (Tại database của mình có 3 document: nodejs, html,js)
				> this : để gọi ra các field với value trong document (VD: this.name để gọi ra value của name trong từng document) 
				- VD: <h1>{{this.name}}</h1>, <img href"{{this.imgae}}">

- 28. Course detail page
	- Tạo thêm các field: slug, videoID tại các document trong database
		vd: slug : nodejs
				
	- Tại file src\app\models\Coures.js thêm vào Schame:
		slug: {type: String},
			> để thêm field vào model 
	
	- Tạo 1 route và 1 controller 1 views cho courses :
		src\app\controllers\SourceController.js
		src\routes\courses.js
		src\resources\views\courses\show.hbs
		
		- Tại file src\app\controllers\SourceController.js cấu hình để truyền data như sau:
				const Course = require('../models/Course');
				const { mongooseToObject } = require('../../util/mongoose');	
				class CoursesController {
					show(req, res, next) {
						Course.findOne({ slug: req.params.slug }) //lấy 1 slug với slug: req.params.slug là query đc lấy về từ url dưới dạng query parameters - VD: url: ...../sources/nodejs quert parameters trả về là nodejs
							.then(courses => { 
								res.render('courses/show', { courses: mongooseToObject(courses) }) //để render ra trang show với truyền data được xử lý theo từng document trong courses - vì đang làm theo từng slug
							})
							.catch(next);
					}
				}
				module.exports = new CoursesController();
					> để render ra trang show với data ứng với slug trong từng document
						> VD: slug là /nodejs -> data truyền vào show sẽ tương ứng với document nào có slug là nodejs
				
		- Tại file src\routes\courses.js cấu hình route như sau:
			- require express, router như các bước tạo route
			
			- Cấu hình:
				router.get('/:slug', coursesController.show);
					> để trỏ route tới /:slug với coursesController.show được require từ CourseController.js 
						> slug là nhánh phát sinh bất kỳ của nhánh /courses
		
		- Tại file src\routes\index.js thêm:
			const coursesRouter = require('./couses');
			app.use('/courses', coursesRouter);
				> để trỏ đường dẫn .../courses/:slug
		
		- Tại src\resources\views\courses\show.hbs:
			- Tạo giao diện cho trang show 
				- Sư dụng {{courses.'tên field'}} để truyền vào data từ document 
					> VD: Truyền video từ Ytube với videoID trong database là ID video của YTube: sử dụng {{videoID}}
						 <iframe width="1029" height="579" src="https://www.youtube.com/embed/{{courses.videoID}}.......

- 29. [CRUD] Create new course
	- Tạo route courses/create:
		- Tại src\routes\courses.js thêm:
			router.get('/create', coursesController.create);
				> để tạo một route tới urses/create (Lưu ý: vẫn phải require express, Router như các route khác và export))
				
	- Tạo phương thức create tại CourseController:
		- Tại src\app\controllers\SourceController thêm phương thức create:
			create(req, res, next) {
				res.render('courses/create')
			}	
				> để tạo phương thức render ra trang create
	
	- Tạo view cho create
		- Tạo file như sau:
			src\resources\views\courses\create.hbs
			
		- Dùng bootstrap tạo giao diện với 1 form có 5 input(Tên khoá học, Mô tả kháo học, Link image, Video ID, Level): 
			- mỗi input thêm một attributes name (với name ứng với field trong database: VD name='description')
			
			- Tại thẻ <form> thêm method="post" action="/courses/store"
				> để set phương thức submit của form là post 
	
	- Tạo cấu trúc Schame để nhận dữ liệu vào database:
		- Tại file src\app\models\Coures.js thêm vào Schame như sau:
			const Course = new Schema({
				name: { type: String },
				description: { type: String },
				image: { type: String },
				videoID: {type: String},
				level: {type: String},
				slug: {type: String, slug: 'name', unique: true}, 
			}, {
				timestamps: true
			});
				> để database nhận được dữ liệu thỳ phải cấu trúc trước các field để lưu vào database
			
			- Để field slug có thể tự nhận data từ field name ta cần cài đặt mongoose-slug-generator:
				>>> npm install mongoose-slug-generator --save
				
				- Tại file src\app\models\Coures.js khai báo như sau:
					const slug = require('mongoose-slug-generator');
					mongoose.plugin(slug);
						> để khi có slug với data trùng nhau, plugin sẽ tự thêm vào slug một shortId ở sau
	- Tạo phương thức POST:
		- Tại src\app\controllers\SourceController thêm phương thức store
			store(req, res, next) {
				const formData = req.body; //Tạo biến formData với req.bod là dữ liệu dạng form data đã submit ở form trên
				const courses = new Course(formData) // Tạo biến courses với Model chứa data từ biến formData
				courses.save() //Lưu data vào database
        .		.then(() => res.redirect('/')) //chuyển hướng đến trang chử http://localhost:3000/
			}
			
		- Tạo route tới	/courses/store với phương thức post
			- Tại src\routes\courses.js thêm 1 route:
				router.post('/store', coursesController.store);
					> để trỏ route tới /courses/store với phương thức post và phương thức store đã tạo ở CourseController (Lưu ý: vẫn phải require express, Router như các route khác và export)

- 30. [CRUD] Update course	
	- Tạo route, controller, view cho /me/stored/courses
		- Tạo 1 file src\resources\views\me\stored-courses.hbs (tạo thêm folder me)
			- Dùng bootstrap tạo giao diện table với 4 cột:
				<thead>
					<tr>
						<th scope="col">#</th>
						<th scope="col">Tên khoá học</th>
						<th scope="col">Level</th>
						<th scope="col">Thời gian tạo</th>
						<th></th>
					</tr>
				</thead>
			
			- Tại src\resources\views\courses\edit.hbs
				- Tạo giao diện tương tự create.hbs (các input tương tự)
	
		- Tạo 1 file src\routes\me.js
			const meController = require('../app/controllers/MeController');
			router.get('/stored/courses', meController.storedCourses);
				> để tạo 1 route tới /stored/courses với MeController, và phương thức storedCourses (Lưu ý: vẫn phải require express, Router như các route khác và export)
		
		- Tại src\routes\index.js 
			const meRouter = require('./me');
			app.use('/me', meRouter);
				> để trỏ router tới /stored/courses => /me/stored/courses
			
		- Tạo 1 file src\app\controllers\MeController.js
			- require model tương tự như các controller khác (Vì vẫn sử dụng model Course)
			
			class MeController {
				storedCourses(req, res, next) {
					Course.find({})
						.then( courses => res.render('me/stored-courses', {courses: multipleMongooseToObject(courses)}))
						.catch(next)
        
				}
				> để tạo phương thức storedCourses cho route vửa tạo và render ra view stored-courses với data courses được truyền vào view
			
	- Truyền data vào table trong view stored-courses.hbs:
		-Tại file src\resources\views\me\stored-courses.hbs thêm phần body của table:
		<tbody>
            {{#each courses}}
            <tr>
                <th scope="row">{{@index}}</th>
                <td>{{this.name}}</td>
                <td>{{this.level}}</td>
                <td>{{this.createdAt}}</td>
                <td>
                    <button type="button" class="btn btn-light">
                        <a style="text-decoration: none;" href="/courses/{{this._id}}/edit">Sửa</a>
                    </button>
                    <button type="button" class="btn btn-light">
                        <a style="text-decoration: none;" href="">Xoá</a>
                    </button>
                </td>
            </tr>
            {{/each}}
        </tbody>
			> Sử dụng {{#each sources}} {{/each}} để lặp từng document trong database
			> Sử dụng {{this.}} để lấy ra value của từng field trong document tương ứng (giá trị của từng trường trong bản ghi)
			> href="/courses/{{this._id}}/edit" để dẫn nút sửa trỏ đến route edit với id tương ứng đc lấy từ document

	- Tạo route, view edit:
		- Tạo file src\resources\views\courses\edit.hbs
			- Tạo giao diện tương tự file src\resources\views\courses\create.hbs
				> để sửa dữ liệu tương ứng với dữ liệu đã tạo
			
		- Tại file src\routes\courses.js thêm 1 router:
			router.get('/:id/edit', coursesController.edit);
				> để trỏ tới /:id/edit với :id là value của field id được truyền vào và trỏ ở stored-courses.hbs
				
		- Tại src\app\controllers\SourceController.js thêm phương thức edit cho route vừa tạo
			edit(req, res, next) {
				Course.findById(req.params.id)
					.then (courses => res.render('courses/edit', {
					courses: mongooseToObject(courses)
					}))
					.catch(next)
			}
				> để render và data truyền vào view edit với id tương ứng với từng document (req.params.id là biến lấy id từ url dưỡi dạng query parameters)
					> VD: Với id của document 1, view edit sẽ đc truyền data (là các field: value) của document 1
			
	- Truyền data vào view edit.hbs:
		-Tại file src\resources\views\courses\edit.hbs:
			- Tại các thẻ <input> thêm attributes value="{{courses.}}"
				> để truyền vào các value từ data trong document ({{couses.name}},{{courses.description}},{{courses.image}},{{courses.videoID}},{{courses.level}})
					> Lưu ý: Nếu truyền vào nhiều document thỳ mới dùng {{#each courses}}, {{this.}} để lặp qua từng document rồi mới dùng {{this.}} để gọi ra value tương ứng trong document còn ở đây đã chỉ rõ document được findById nên dùng {{courses.}} để gọi ra value luôn
	
	- Vì html ko hỗ trợ submit với phwuong thức put => phải dùng method-override của Express
		>>> npm install method-override
		
		- Tại file src/index.js:
			const methodOverride = require('method-override')
			app.use(methodOverride('_method'))

		- Tại thẻ <form> trong  file src\resources\views\courses\edit.hbs sửa như sau:
			<form method="post" action="/courses/{{courses._id}}?_method=PUT">
				> để submit form với phương thức PUT
			
		- Tạo route với phương thức put tại src\routes\courses.js :
			router.put('/:id', coursesController.update);
				> để trỏ route tới courses/:id với phương thức put và controller với phương thức update
		
		- Tạo phương thức update tại src\app\controllers\CourseController.js
			update(req, res, next){
				Course.updateOne({ _id: req.params.id}, req.body)
					.then(() => res.redirect('/me/stored/courses'))
					.catch(next)
			}
				> để update data đã nhập ở view edit.hbs và đã được lưu ở biến req.body (khi submit form data ở form được luu dưới dạng form data và gán vào biến body)
				> req.params.id : là id đc lấy trên url 
				> { _id: req.params.id}: để chỉ ra document có field và value tương ứng để update
				> Sau khi update đc điều hướng (redirect) về view stored-courses.hbs
			
- 31. [CRUD] Delete course
	- Tại file src\resources\views\me\stored-courses.hbs
		- Dùng bootstrap tạo một nút xoá (cùng nằm trong thẻ <td> với nút sửa đã tạo) và tạo 1 modal (giao diện con) khi ấn nút xoá
			> để tạo thông báo xác nhận xoá cho người dùng
		
	- Tại file src\routes\courses.js thêm một route với phương thức delete:
		router.delete('/:id', coursesController.delete);	
			> để trỏ route tới courses/:id với phương thức delete
		
	- Tại file src\app\controllers\CourseController.js thêm một phương thức delete cho route vừa tạo
		delete(req, res, next) {
			Course.deleteOne({ _id: req.params.id })
				.then(()=> res.redirect('back'))
				.catch(next)
		}	
			> Course.deleteOne({ _id: req.params.id }) : để tìm đến 1 document và xoá nó trong database với điều kiện field _id trong document trùng với id có trong document đó (id của document được lấy bởi req.params.id là id trên url)
			> .then(()=> res.redirect('back')) : Sau khi xoá response được điều hướng (redirect) về trang trước ('back') hoặc ('/me/stored/courses')
	
	- Để lấy id của document khi ấn nút Xoá:
		- Tại file src\resources\views\me\stored-courses.hbs 
			- Tại thẻ <a> chứa nút Xoá thêm attributes: data-id="{{this._id}}"
				<a style="text-decoration: none;" data-toggle="modal" data-id="{{this._id}}" data-target="#delete-course-modal" href="">Xoá</a>
					> để khi nhấn nút Xoá attributes data-id nhận được id của từng document được gọi ra bởi {{this.id}} (Vì nút Xoá cũng đang nằm trong vòng lặp {{#each courses}} được tạo để lấy dữ liệu của từng document ở Bài 30 )
		
		- Sử dụng JS để lấy id khi ấn nút Xoá và truyền vào modal (Có trên cách lấy data-whatever của bootstrap)
			document.addEventListener('DOMContentLoaded', function() { //Khi nút Xoá được nhấn
				var courseId; //Khai báo biến để nhận id

				$('#delete-course-modal').on('show.bs.modal', function (event) { //#delete-course-modal là data-target trên nút xoá
				  var button = $(event.relatedTarget)
				  courseId = button.data('id') //gán giá trị của data-id đã tạo ở trên vào biến courseId
				})
			  })
		
	- Tại modal đã tạo ở trên:
		- thêm id cho thẻ chứa nút xác nhận:
			<button id="btn-delete-course" type="button" class="btn btn-danger">Xác nhận</button>
	
		- Trong function tại document.addEventListener('DOMContentLoaded', function() thêm:
			var btnDeleteCourse = document.getElementById('btn-delete-course')
				> để gán nút Xác nhận vừa tạo vào biến btnDeleteCourse
		
	- Để khi nhấn nút Xác nhận trên modal sẽ tạo ra phương thức delete được trỏ bởi route đã tạo:
		- Tại file src\resources\views\me\stored-courses.hbs
			- Tạo một form rỗng với name và method="POST"
				<form name="delete-course-form" method="post"></form>
					> để có thể truyền attributes action khi submit form thông qua nút Xác nhận
			
			-  Trong function tại document.addEventListener('DOMContentLoaded', function() thêm:
				var deleteForm = document.forms['delete-course-form']
					> để gán form vừa tạo vào biến deleteForm
					
				btnDeleteCourse.onclick = function () {
					deleteForm.action = '/courses/' + courseId + '?_method=DELETE'
					deleteForm.submit()
				} 
					> để khi nút Xác nhận được nhấn (btnDeleteCourse.onclick) thỳ thẻ <form> sẽ được thêm action (deleteForm.action) và submit(deleteForm.submit())
					> '/courses/' + courseId + '?_method=DELETE' : gọi route tới /courses/:id?_method=DELETE với :id là biến courseId và ?_method=DELETE là override sang phương thức DELETE đã làm tương tự với PUT ở bài 30
			
32. Soft delete? (Xoá mềm - Sử dụng cho những dữ liệu nhạy cảm cần lưu lại ở database khi đã xoá)
		>>> npm i mongoose-delete
		
		- Tại file src\app\models\Course.js:
			const mongooseDelete = require('mongoose-delete');
				> để require thư viện mongoose-delete
				
			Course.plugin(mongooseDelete);
				> để thêm plugin vào Course (gắn plugin vào sau khi tạo Course = new Schema)
				
		- Tại src\app\controllers\CourseController.js:
			- Tại phương thức delete đã tạo sửa Course.deleteOne thành Course.delete
				> Course.delete: sử dụng phương thức delete của thư viện mongoose-delete (delete ở đây mà xoá mềm - tại database sẽ đc tạo thêm 1 field delete: true)
		
		- Để chỉ show ra những bản ghi chưa xoá mềm: (Bước trên chỉ sửa field delete những bản ghi bị xoá thành true)
			- Tại file src\app\models\Course.js:
				- Thêm một đối số vào plugin của Course:
					Course.plugin(mongooseDelete,{ overrideMethods: 'all' });
						> để ghi đè lên phương thức như: find, findOne,.... của mongoose (không lấy những bản ghi với điều kiện delete: true - có thế viết: overrideMethods: 'true')
				
				-Thêm deleteAt: true vào đối số vừa thêm:
					{ overrideMethods: 'all', deleteAt: true}
						> để tạo thêm một field ghi thời gian xoá
		- Show ra những bản ghi đã xoá mềm (để khôi phục hoặc xoá vĩnh viễn):
			- Tạo route controller view tới /me/trash/courses
				- Tại src\routes\me.js thêm một route tới /trash/courses với phương thức get và truyền vào controller phương thức trashCourses
					router.get('/trash/courses', meController.trashCourses);

				- Tại src\app\controllers\MeController.js thêm phương thức trashCourses render ra view trash-courses
					trashCourses(req,res,next) {
						Course.find({})
							.then((courses) =>
								res.render('me/trash-courses', {
									courses: multipleMongooseToObject(courses),
								}),
							)
							.catch(next);
					}
					
				- Tại src\resources\views\me tạo 1 view trash-courses.hbs (copy file stored-courses.hbs - giao diện tương tự)
					- Để lấy ra các bản ghi đã xoá:
						- Tại src\app\controllers\MeController.js:
							- sửa Course.find({}) thành Course.findDeleted({}) tại phương thức trashCourses
								> để tìm những bản ghi đã xoá mềm (delete: true) và truyền vào view
					
					- Sửa nút Sửa, Xoá thành Khôi phục, Xoá vĩnh viễn (vì copy giao diện của stored-courses.hbs)
						- Khôi phục:
							- tại thẻ <a> của nút Khôi phục bỏ đường dẫn ở href, thêm  class="btn-restore" và attributes data-id="{{this._id}}"
								> để nhận id tương ứng từ database vào nút Khôi phục
							
							- Tạo route, controller để thực hiện khôi phục:
								- Tại src\routes\courses.js:
									router.patch('/:id/restore', coursesController.restore);
										> để tạo route tới /:id/restore với thường thức patch và truyền vào CourseController phương thức restore
											> sử dụng phương thức patch vì ở đây chỉ cần update lại 1 field delete của database
											
								- Tại src\app\controllers\CourseController.js tạo phương thức restore:
									restore(req, res, next) {
										Course.restore({ _id: req.params.id })
											.then(()=> res.redirect('back'))
											.catch(next)
									}
										> Course.restore để trả lại giá trị của field delete về false
							
							- Tạo 1 form rỗng 
								<form name="restore-course-form" method="post"></form>
									> để thực hiện hành vi submit khi ấn nút Khôi phục
									
							- Tại phần script
								var restoreBtn = $('.btn-restore') 
									> dùng JQuery để gán các nút Khôi phục vào biến restoreBtn
									
								var restoreForm = document.forms['restore-course-form']
									> để gán form rỗng vừa tạo vào biến restoreForm
									
								restoreBtn.click(function (e) {
								  e.preventDefault()
								  var courseId = $(this).data('id')
								  restoreForm.action = '/courses/' + courseId + '/restore?_method=PATCH'
								  restoreForm.submit()
								})
									> restoreBtn.click để bắt sự kiện click cho nút khôi phục
									> e.preventDefault() để bỏ hành vi mặc định của thẻ <a> trong nút Khôi phục (khi ấn vào thẻ <a> sẽ trỏ đến đường dẫn trong href)
									> var courseId = $(this).data('id') : dùng JQuery gán id lấy từ attributes add-id của thẻ a vào biến courseId
									> restoreForm.action = '/courses/' + courseId + '/restore?_method=PATCH' : để thêm action khi submit form restore trả về đường dẫn /course/:id/restore?_method=PATCH với phương thức được override từ POST sang PATCH (?_method=PATCH)
						
						- Xoá vĩnh viễn:
							- Tạo một route và controller để thực hiện xoá vĩnh viễn:
								- Tại src\routes\courses.js:
									router.delete('/:id/force', coursesController.forceDelete);
										> để tạo một route tới /:id/force với phương thức delete và truyền vào CourseController phương thức forceDelete
								
								- Tại src\app\controllers\CourseController:
									forceDelete(req, res, next) {
										Course.deleteOne({ _id: req.params.id })
											.then(()=> res.redirect('back'))
											.catch(next)
									}
										> để tạo phương thức forceDelete
											> Course.deleteOne : để xoá 1 bản ghi tại database (deleteOne được sử dụng của thư viện mongoose)
								
								-Tại src\resources\views\trash-courses.hbs
									- phần script:
										- trong funtion của btnDeleteCourse.onclick (được có sẵn vì copy từ stored-courses.hbs)
											- Sửa  deleteForm.action = '/courses/' + courseId + '/force?_method=DELETE'
												> để thêm action khi submit form delete (được tạo sẵn vì copy) trả về đường dẫn /course/:id/force?_method=DELETE với phương thức được override từ POST sang DELETE

- 33. Deleted count documents	
	- Sử dụng phương thức countDocumentsDeleted() của thư viện mongoose-delete để đếm số bản ghi đã xoá
		- Tại file src\app\controllers\MeController.js:
			- Tại phương thức storedCourses():
				storedCourses(req, res, next) {
					Promise.all([Course.find({}), Course.countDocumentsDeleted()])
						.then(([courses, deletedCount]) =>
							res.render('me/stored-courses', {
								deletedCount,
								courses: multipleMongooseToObject(courses),
							}),
						)
						.catch(next);
				
				}
					> để gộp 2 phương thức find() và countDocumentsDeleted() (find() đã được tạo từ bài trước)-(countDocumentsDeleted() sẽ trả về số bản ghi đã xoá)
					> .then(([courses, deletedCount]) giá trị trả về của 2 phương thức được gán vào 2 biến tương ứng theo thứ tự
					> Sau đó truyền vào view stored-courses.hbs 2 biến courses và deletedCount
		
		- Tại src\resources\views\me\stored-courses.hbs
			- để gọi biến deletedCount đã truyền lên giao diện sử dụng {{deletedCount}}
				<a href="/me/trash/courses">Thùng rác ({{deletedCount}})</a>
				
- 34. "Select all" with checkbox
	- tại file src\resources\views\me\stored-courses.hbs
		- Dùng bootstrap tạo 1 checkbox 1 thanh select 1 nút (nút disable)
			[] Chọn tất cả [ -- Chọn hành động -- ] [Thực hiện] (Giao diện kiểu như này)
			
		- Select:
			<select class="form-control form-control-sm select-checkbox-option" name="action" required>
				<option value="">-- Chọn Hành động --</option>
				<option value="delete">Xoá</option>
			</select>
			
		- thêm checkbox thành vào đầu của thẻ <tr> trong phần tbody của table:
				<td>
                  <div class="form-check " >
                    <input class="form-check-input" type="checkbox" value="{{this._id}}" name="courseIds[]">
                  </div> 
                </td>
					> để tạo nút checkbox cho mỗi document được lấy từ database ở bài trước
					> value="{{this._id}}" để gán id của từng document vào value (để mỗi check box tương ứng với một document)
		
		- Dùng jquery để tạo logic khi checkbox:
			- đặt id cho checkbox Chọn tất cả: 
				id="checkbox-all"
				
			- tạo thêm class check-all-submit-btn cho nút thực hiện
				<button class="btn btn-primary check-all-submit-btn disabled">Thực hiện</button>
			- Tại script:
					var checkAllSubmitBtn = $('.check-all-submit-btn')
						> gán nút Thực hiện vào biến checkAllSubmitBtn
			
					function renderCheckAllSubmitBtn() {
					  var checkedCount = $('input[name="courseIds[]"]:checked').length
					  if (checkedCount > 0) {
						checkAllSubmitBtn.removeClass('disabled')
					  } else { checkAllSubmitBtn.addClass('disabled')}
					}   
						> để tạo một function kiểm tra số nút checkbox của item đã check và trả về trạng thái của nút thực hiện (enable hay disable)
							> Nếu có một checkbox nào được check thỳ nút Thực hiện sẽ hiện lên để submit
			
				    var checkboxAll = $('#checkbox-all')
						> để gán nút checkbox cho biến checkboxAll
						
					var courseItemcheckbox = $('input[name="courseIds[]"]')
						> để gán nút checkbox của các document
				
				- Để Chọn tất cả thỳ các nút check ở list document cũng được check tất cả:
					checkboxAll.change(function() {
						var isCheckedAll = $(this).prop('checked')
						courseItemcheckbox.prop('checked', isCheckedAll)
						renderCheckAllSubmitBtn()
					  
					}) 
						> $(this).prop('checked') để kiểm tra sự kiện check của nút chọn tất cả (trả về true false)
						> var isCheckedAll = $(this).prop('checked') gán giá trị boolean vào biến isCheckedAll
						> courseItemcheckbox.prop('checked', isCheckedAll) : Nếu nút chọn toàn bộ được check (true) thỳ tất cả các nút checkbox của list bản ghi cũng sẽ tự động được check
						> Sau đó gọi function renderCheckAllSubmitBtn() để hiển thị nút Thực hiện
						
				- Để khi tất cả các checkbox của list document được check thỳ nút Chọn tất cả cũng đc check:
					courseItemcheckbox.change(function () {
					  var isCheckedAll = courseItemcheckbox.length === $('input[name="courseIds[]"]:checked').length
					  checkboxAll.prop('checked', isCheckedAll)
					  renderCheckAllSubmitBtn()
					})
						> var isCheckedAll = courseItemcheckbox.length === $('input[name="courseIds[]"]:checked').length: để so sánh số nút đã check với tổng số nút tại list rồi gán vào biến isCheckedAll
							> Nếu tất cả các nút ở list đã check hết (true) thỳ nút Chọn tất cả cũng được check
							> Sau đó gọi function renderCheckAllSubmitBtn() để hiển thị nút Thực hiện
				
				- Tạo form chứa content của cả giao diện với phương thức method="post" action="/courses/handle-form-action":
					<form name="container-form" method="post" action="/courses/handle-form-action" class="mt-4">
						> để khi nhấn nút Thực hiện sẽ submit form chứa toàn bộ các nút checkbox
						
				- Để khi nút Thực hiện được hiện thị thỳ mới có thể submit form:
					checkAllSubmitBtn.on('submit', function(e) {
					  var isSubmitable = $(this).hasClass('disabled') //để kiểm tra xem nút Thực hiện có class disable hay ko (trả về true/ false)
					  if (isSubmitable) {
						e.preventDefault()
					  }
					})
						> Khi nút thực hiện submit => kiểm tra xem nút hiển có hiện ko => nếu không hiện (có class="disable") thỳ ngăn nút Thực hiện submit

		
	- Tạo route và controller khi ấn nút Thực hiện
		- Tại src\routes\courses.js:
			- thêm một route /handle-form-action tương ứng với action của form (thêm trên route /:id vì có thể bị hiểu nhầm /handle-form-action là id)
				router.post('/handle-form-action', coursesController.handleFormAction);
					> Trỏ rotue tới courses/handle-form-action với phương thức post và truyền vào CourseController phương thức handleFormAction
		
		- Tại src\app\controllers\CourseController.js:
			- Thêm phương thức handleFormAction:
				handleFormAction(req, res, next) {
					switch(req.body.action) {
						case 'delete':
							Course.delete({ _id: { $in: req.body.courseIds} })
								.then(()=> res.redirect('back'))
								.catch(next)
							break;
						default: 
							res.json({message: 'Action invalid'})
					}
				}
					> req.body.action : với action là value của một <option> trong <select name="action">  
					> Course.delete({ _id: { $in: req.body.courseIds} }) : Xoá các document theo id được gửi lên request khi submit
						> _id: { $in: req.body.courseIds}: vì courseIds là một mảng (có thể có nhiều checkbox được check) => dùng { $in: req.body.courseIds} để xét từng phần tử trong mảng courseIds 
					> Dùng switch case để có thể áp dụng làm với nhiều option khác (restore, deleteOne,......)
		
- 35. Fix bug
	- Tại file src\resources\views\me\stored-courses.hbs
		- tại thẻ <button> của nút Thực hiện :
			- bỏ class disabled vào thêm attributes disabled="disabled"
				<button class="btn btn-primary check-all-submit-btn" disabled="disabled">
					Thực hiện
				  </button>
				  > vì class disabled thêm ở bài trước chỉ là một class được bootstrap css sẵn màu sắc chứ ko thực sự là disabled
				  
		- Tại script:
			- bỏ phương thức kiểm tra nút Thực hiện submit:  checkAllSubmitBtn.on('submit', function(e)
				> vì nút Thực hiện đã disable thỳ ko thế submit nữa => ko cần kiểm tra
			
			- sửa lại function kiểm tra checkbox và enable cho nút Thực hiện:
				function renderCheckAllSubmitBtn() {
				  var checkedCount = $('input[name="courseIds[]"]:checked').length
				  if (checkedCount > 0) {
					checkAllSubmitBtn.attr('disabled', false)
				  } else { checkAllSubmitBtn.attr('disabled', true)}
				}    
					> Nếu có một nút checkbox dược check (checkedCount > 1) thỳ attributes disabled sẽ bị remove (checkAllSubmitBtn.attr('disabled', false))
					
-37. Sort middleware:
	- Tại src\resources\views\me\stored-courses.hbs
		- Tại cột Tên khoá học thêm một thẻ <a> với 1 icon: 
			<th scope="col">
                  Tên khoá học
			  <a href="?_sort&column=name&type=asc"><span class="ti-arrows-vertical"></span></a>
			</th>
				> href="?_sort&column=name&type=asc" : để truyển query parameters lên url:
					> _sort: là chắc năng sắp xếp (tên do mình tự định nghĩa)
					> column: là cột với giá trị ở đây là name (cột name) (tên do mình tự định nghĩa - tại đây gán giá trị = name vì thẻ <a> đang ở cột Tên khoá học)
					> type: là kiểu sắp xếp (tên do mình tự định nghĩa) với giá trị = desc (giá trị cũng tự định nghĩa desc/asc : tăng dần/ giảm dần)
				
	- Sắp xếp:
		- Tại src\app\controllers\MeController.js
			- Trong phương thức storedCourses(req, res, next)
				- Kiểm ra xem đã truyền lên url _sort chưa:
					if(req.query.hasOwnProperty('_sort')) {
						res.json({message: 'successfully!!'})
						return
					}
						> req.query.hasOwnProperty('_sort') : kiểm tra _sort có trên url ko
			
				- Để sắp xếp:
					- Lấy phương thức find data từ database và gán vào biến courseQuery
						let courseQuery = Course.find({})
							> Course.find({}) là phương thức lấy ra data từ database học ở bài trước
							> dùng let để có thể gán lại giá trị cho biến (ko dùng const)
							> sau khi khai báo thay Course.find({}) bằng biến courseQuery ở phương thức Promise.all:
								Promise.all([courseQuery, Course.countDocumentsDeleted()])
									> để có thể lấy được giá trị đã sắp xếp vào truyền vào view
						
					- Trong if(req.query.hasOwnProperty('_sort')):
						courseQuery = courseQuery.sort({
							name : 'asc'
						})
							> để sắp xếp giá trị trong field name của database theo asc (tăng dần)
							> courseQuery.sort là hàm sắp xếp của mongoose (sort ({tên cột: 'kiểu sắp xếp'})
							> Đây là demo sắp xếp chưa liên quan gì đến giá trị của url
					
						- Để truyền biến động từ url:
							- Trong courseQuery.sort():
								[req.query.column]: req.query.type
									> req.query.column : giá trị của column trên url ('?_sort&column=name&type=asc' tại đây = name tương ứng với field name trong database)
									> req.query.type: giá trị của type trên url ('?_sort&column=name&type=asc' tại đây = asc - có thể đổi thành desc trên url để xem thử kiểu sắp xếp giảm dần)
	
	-Sử dụng middleware: 
		-Tạo file folder như sau:
			src\app\middlewares\SortMiddleware.js
				> để tạo một middleware cho việc sắp xếp
			
		-Tại src\app\middlewares\SortMiddleware.js:
			module.exports = function SortMiddleware(req, res, next) {
				res.locals._sort = {
					enabled: false,
					type: 'default'
				}

				if (req.query.hasOwnProperty('_sort')) {
					res.locals._sort.enabled = true;
					res.locals._sort.type = req.query.type
					res.locals._sort.column = req.query.column
				}
				next()
			}	
				> res.locals: một thuộc tính của express giúp truyền biến vào view (biến có thể là đường dẫn, vv) và chỉ nằm trong một yêu cầu (request)
				> res.locals._sort = {
					enabled: false,
					type: 'default'
				}
					> để định nghĩa cho biến res.locals._sort
						> enabled: false: mặc định chức năng sắp xếp không hoạt động
						> type: 'default': mặc định type
					
				if (req.query.hasOwnProperty('_sort')) {
					res.locals._sort.enabled = true;
					res.locals._sort.type = req.query.type
					res.locals._sort.column = req.query.column
				}
					> Kiểm tra trên url (req.query) nếu có _sort thỳ bật chức năng sort (res.locals._sort.enabled = true) và kiểu sắp xếp,cột được trả về từ yêu cầu trên url (req.query.type ,req.query.column)
			
		- Tại src\index.js:
			- Require middleware vừa tạo:
				const SortMiddleware = require('./app/middlewares/SortMiddleware')

			app.use(SortMiddleware)
				> để sử dụng middleware cho toàn bộ chương trình:
				
		-Có thể kiếm tra xem biến res.locals._sort đã truyền vào view chưa:
			- Tại views stored-courses.hbs truyền vào biến _sort:
				{{_sort.type}}
					> biến sẽ trả về giá trị của type tương ứng trên url (thay đổi type='giá trị bất kì' trên '?_sort&column=name&type=asc' để thấy)
		
		- Sử dụng helpers của handlebars để	sử lý thay đổi icon khi ấn vào để sắp xếp (mỗi khi ấn vào icon (là thẻ <a> chứa icon) sẽ thay đổi kiểu sắp xếp và icon cũng thay đổi theo kiểu sắp xếp)
			- Tại src/index.js:
				- Tại app.engine() 
					- Trong engine thêm helpers như sau:
						app.engine(
							'.hbs',
							engine({
								extname: '.hbs',
								helpers: {
									sortable: (field, sort) => {
										const sortType = field === sort.column ? sort.type: 'default'
										const icons = {
											default : 'ti-arrows-vertical',
											asc: 'ti-download',
											desc: 'ti-upload'
										}
										const types ={
											default : 'desc',
											asc: 'desc',
											desc: 'asc'
										}
										const icon = icons[sortType]
										const type = types[sortType]
										return `<a href="?_sort&column=${field}&type=${type}"><span class="${icon}"></span></a>`
									}
								},
							}),
						);
							> sortable: (field, sort) => {} : khai báo một helpers tên là sortable là function với 2 tham số field, sort (sẽ được tryền vào view tương ứng: field là tên field trong database, sort là biến _sort được tạo ở middleware)
							
								const sortType = field === sort.column ? sort.type: 'default'
									> để kiểm tra tham số field(field trong database) có bằng sort.column (giá trị của column trên url) không? Nếu không có giá trị tương ứng sẽ trả về 'default' 
									
								const icons = {
									default : 'ti-arrows-vertical',
									asc: 'ti-download',
									desc: 'ti-upload'
								}
									> để cấu hình các dạng icon theo deafault, asc, desc
								
								const types ={
									default : 'desc',
									asc: 'desc',
									desc: 'asc'
								}
									> để cấu hình type deafault, asc, desc
									
								const icon = icons[sortType]
								const type = types[sortType]	
									> để khai báo 2 biến icon và type với giá trị được lấy trong các cấu hình tương ứng với sortType (Nếu sortType='asc' thỳ icon sẽ đc lấy ra kiểu icon asc và type cũng lấy ra kiểu asc  )
								
								return `<a href="?_sort&column=${field}&type=${type}"><span class="${icon}"></span></a>`
									> để khi gọi helper sortable sẽ trả ra icon với các giá trị truyền vào tương ứng
									
				- Tại view stored-courses:
					-Gọi helper sortable vừa tạo thay cho thẻ <a> chứa icon đã tạo từ trc:
						- thay thế thẻ <a> chứa icon bằng {{{sortable 'name' _sort}}}
							> Trong {{{sortable 'name' _sort}}}: > sortable để gọi ra function return ra thẻ <a> chứa icon
																 > 'name' và _sort là 2 tham số truyền vào function trên với 'name' là tên của field trong database, _sort là biến được lấy từ middleware (sort.column, sort.type trong function trên tương đương _sort.column, _sort.type)	
				
						- Tương tự gọi helper với các cột còn lại để thêm icon sắp xếp: {{{sortable 'level' _sort}}}  , {{{sortable 'createdAt' _sort}}}  
						
	=> Khi bấm vào icon sắp xếp tại các cột -> gửi lên url request với phương thức _sort column tương ứng với cột với type mặc định ban đầu là desc / cùng lúc controller sẽ thực hiện sắp xếp theo tên field = giá trị column , kiểu sắp xếp = giá trị type trên url 
		-> middleware kiểm tra trên url có _sort -> gắn vào biến _sort các cấu hình column, type -> view gọi helpers sortable với field và _sort để thay đổi icon(thay đổi href và class của icon)  -> lúc này icon đã được thay đường dẫn và kiểu icon 
				
				
						
- 38. Autoincrement _id field					
		>>> npm install --save mongoose-sequence
			> cài thư viện mongoose-sequence
			
		- tại src\app\models\Course.js:
			const AutoIncrement = require('mongoose-sequence')(mongoose);
				> để require thư viện mongoose-sequence
			
		- tại phần khai báo Schame Course:
			- ở option thứ nhất (khai báo các field):
				_id: {type: Number},
					> để khai báo kiểu dữ liệu cho field _id
			
			- ở option thứ 2:
				_id: false
					> để mongodb ko tự thêm id vào field _id nữa
					
		- Course.plugin(AutoIncrement)
			> để apply plugin vào Chema
		
		=> thư viện sẽ tự thêm id tăng dần cho mỗi document (bản ghi)
						
		- Tại src\resources\views\me\stored-courses.hbs:
			- Dùng helper sortable đã tạo ở bài trước để thêm icon với chức năng sắp xếp: 
                  {{{sortable '_id' _sort}}}
			
			- Dùng {{this._id}} để gọi ra giá trị của field _id trong database
		
